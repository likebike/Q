<%inherit file="_master_pretty.html.tmpl" />
<%
    import glob, os
    latest = os.path.basename(sorted(glob.glob(os.path.join(os.environ['WWW_ROOT'], 'bigfiles/Q-*.tar.gz')))[-1])
    latestURL = '/bin/%s'%(latest,)
%>

<h1>What is Q?</h1>
<p>Q is a serverless, general-purpose process queue specifically designed for running CGI and PHP at <a href="http://webfaction.com/">WebFaction</a>.</p>
<p>Normally, CGI and PHP at WebFaction are great, except for one problem: there is no limit to the number of CGI workers that can get created.  So during a traffic spike, it is easy to exceed your account's RAM limits, resulting in all your processes getting killed.  FastCGI is often recommended as an alternative because it allows you to specify the number of worker processes that should be created.  Unfortunately, due to some problems with Apache's FastCGI module, many sites produce intermittent "500" errors, or stop responding altogether.  As a result, neither the CGI mode, nor the FastCGI mode is really acceptable for sites that need very high reliability.</p>
<p>Q fixes this problem by only allowing a defined number of CGI workers to run concurrently.  Any additional requests that come in get queued and execute in FIFO order.  This enables you to easily control the maximum amount of RAM you use during traffic spikes.  This solution makes CGI a viable option again.</p>
<p>Q is developed by <a href="mailto:csebastian3@gmail.com">Christopher Sebastian</a> and <a href="mailto:ryan@ryansanden.com">Ryan Sanden</a> (both of whom work at WebFaction).  Feel free to ask us questions and send feedback.</p>
<h1>Installation</h1>
<p>Installation consists of two pieces: downloading a Q binary, and then referencing the binary from your website's .htaccess file.</p>
<ol>
  <li>
    <p>In all of the below instructions, make the following name substitutions:</p>
    <ul>
      <li><span class=mono>APP</span> = Your Application Name, defined in the WebFaction Control Panel, and corresponding to a folder under <span class=mono>~/webapps/</span>.</li>
      <li><span class=mono>Q.cgi</span> = The actual filename that you download from the table below (probably <span class=mono>php54_normal.cgi</span>).</li>
    </ul>
    <p>Download an appropriate binary, give it a proper set of permissions, and place it at <span class=mono>~/webapps/APP/</span>.  You can do this from the command line like this:</p>
<pre class=code>
cd ~/webapps/APP/
curl -O http://q.likebike.org/bin/centos6/Q.cgi    ${'#'}${'#'}# Replace this URL with the appropriate one from the table below.
chmod 755 Q.cgi
</pre>

    <h3>If your account is on a CentOS 6 server (Web300 or higher):</h3>
    ${self.DL_TABLE('CentOS 6', '/bin/centos6')}
    <h3>If your account is on a CentOS 5 server (Web299 or lower):</h3>
    ${self.DL_TABLE('CentOS 5', '/bin/centos5')}
    <p>Here is a link to the <a href="${latestURL}">latest source code</a>.  You can also browse the <a href="/bin">distribution mirror</a>.</p>
  </li>

  <li>
    <p>Edit your <span class=mono>~/webapps/APP/.htaccess</span> file and add these lines to the top of the file.  Remember to replace both instances of <span class=mono>Q.cgi</span> with the actual file you downloaded:</p>
<pre class=code>
&lt;FilesMatch ^Q.cgi$&gt;
    SetHandler cgi-script
&lt;/FilesMatch&gt;
Action php-q /Q.cgi
&lt;FilesMatch \.(?i:php)$&gt;
    SetHandler php-q
&lt;/FilesMatch&gt;
</pre>
    <p>That's it!  Once you save these changes, your site will be running from Q!</p>
  </li>
</ol>
<h1>Frequently Asked Questions</h1>
<p>If you have a question that is not addressed here, please send it to <a href="mailto:csebastian3@gmail.com">Christopher</a>.</p>
<ul>
  <li>
    <h3>Which PHP version am I running?</h3>
    <p>Create an <span class=mono>info.php</span> file in your web app with the following contents:</p>
<pre class=code>
&lt;?php phpinfo(); ?&gt;
</pre>
    <p>When you visit that page, the PHP version will be printed at the top of the screen.  Remember to delete the info.php file when you are done with it so other people can't see your settings!</p>
  </li>
  <li>
    <h3>What is the difference between the "normal" and "large" binaries?</h3>
    <p>They are configured to run different numbers of concurrent processes.  The "normal" settings are appropriate for basic WebFaction accounts, and the "large" settings are better for accounts with more RAM.</p>
  </li>
  <li>
    <h3>I am using Q, but I forgot which one I downloaded.  How can I see which Q settings I am currently using?</h3>
    <p>Run your Q binary with the <span class=mono>HELP=1</span> environment defined, as shown below.  The resulting help message will list your settings.</p>
<pre class=code>
HELP=1 ./Q.cgi
</pre>
  </li>
</ul>
<h1>Performance &amp; Reliability</h1>
<ul>
  <li>Q is implemented in C, and depends only on the C standard library.  Because of this, it is easy to build on any Linux system.</li>
  <li>Q uses Linux Record Locking for inter-process communication.  This method is very fast and it does not involve any filesystem activity, other than the one-time creation of a lockfile.</li>
  <li>Since Linux Record Locking is managed by the Linux Kernel, the queue is guaranteed to never get "stuck", even if processes crash or are sent un-handleable signals like SIGSTOP and SIGKILL.</li>
  <li>On a 32-bit system, a Q process uses around 430kB of RSS memory (most of which is from the standard C library, and therefore shared).  On a 64-bit system, a Q process uses around 540kB.</li>
  <li>Q uses intelligent binary search algorithms, along with other optimizations, to achieve excellent scalability and low-resources usage.  It is able to manage more processes than the Linux Kernel is currently able to handle.  (In other words, Q will never be the performance bottleneck.)</li>
</ul>
<h1>How Q Works</h1>
<div class=exampleContainer>
  <div class=exampleSidebar>
    <p>This example introduces how to use <span class=progName>Q</span> as a general process queue tool.  This mode of operation is very flexible and powerful, and ideal for interactive, command-line-based tasks.</p>
    <p>Two <span class=progName>Q</span> options are introduced:</p>
    <ul>
      <li><span class=mono>COMMAND</span> -- The path to the target command.  (The only required parameter.)</li>
      <li><span class=mono>CONCURRENCY</span> -- The number of processes to run simultaneously.</li>
    </ul>
  </div>
  <h2>Example #1: Running <span class=mono>N</span> Processes at a Time</h2>
  <p>Pretend that you have written a program named <span class=progName>SWAAG</span>, which converts <a href="http://xkcd.com/979/">images</a> to <a href="xkcd_979.html">ASCII art</a>.  The generation of this ASCII art is very CPU-intensive, but not demanding in terms of RAM or Disk I/O.  <span class=progName>SWAAG</span> is single-threaded and synchronous, so it only uses one CPU core when it runs.  Also pretend that your computer has 4 CPU cores, but you only want to use 3 of them for ASCII art conversions.  (You need the other core for <strike>productivity</strike> YouTube.)  You have a directory with 100 images that you need to convert, named <span class=mono>image00.png</span> to <span class=mono>image99.png</span>.</p>
  <p class=codeIntro><span class=progName>Q</span> makes these kinds of tasks easy.  You would just need to type this <span class=progName>bash</span> command:</p>
<pre class=code>\
for image in image*.png; do
    COMMAND=swaag CONCURRENCY=3 ./Q "$image" &amp;
done
<!-- COMMAND=swaag CONCURRENCY=3 ./Q -m ascii_ext -s putty-CourierNew-8 sandwich2.png -->
</pre>
  <p>Here are some graphical views of the execution (click to enlarge):</p>
  <div class="imgContainer padRight">
    <div class=imgTitle>Execution Status, Per-Image View</div>
    <a href="${self.URL('/static/img/q_ex1_image_view_1024.png')}"><img src="${self.URL('/static/img/q_ex1_image_view_500.png')}"></a>
  </div>
  <div class=imgContainer>
    <div class=imgTitle>Execution Status, System View</div>
    <a href="${self.URL('/static/img/q_ex1_system_view_1024.png')}"><img src="${self.URL('/static/img/q_ex1_system_view_500.png')}"></a>
  </div>
  <p>There are several phases of execution, as shown in the diagrams above:</p>
  <h3>The <span class=mono>START</span> Phase:</h3>
  <p>This is the point right before you type the above command and press <span class=mono>ENTER</span>.  At this point, no <span class=progName>Q</span> or <span class=progName>SWAAG</span> processes are running.</p>
  <h3>The <span class=mono>QUEUEING</span> Phase:</h3>
  <p>This phase represents the fraction of a second when the above bash loop is running.  The bash loop quickly launches 100 <span class=progName>Q</span> processes in the background.  At the end of this phase, you will momentarily have approximately 100 <span class=progName>Q</span> processes running:
<pre class=code>\
$ ps -o pid,rss,%cpu,cmd -p $(pgrep -u $USER '^Q$|^swaag$')
  PID    RSS  %CPU  CMD
 1000    540   0.0  Q
 1001    540   0.0  Q
 1002    540   0.0  Q
 1003    540   0.0  Q
 1004    540   0.0  Q
 1005    540   0.0  Q
 ...
 ...
 1097    540   0.0  Q
 1098    540   0.0  Q
 1099    540   0.0  Q
</pre>
  <p>Immediately, 3 of the <span class=progName>Q</span> processes will convert themselves into <span class=progName>SWAAG</span> processes (because we specified <span class=mono>CONCURRENCY=3</span>).  Note that the original process ID (<span class=mono>PID</span>) numbers will be retained, since <span class=mono>exec</span> is used (this is a critical feature for many advanced cases).  At that point, there would be 3 <span class=progName>SWAAG</span> processes and 97 <span class=progName>Q</span> processes.  The process listing would look something like this:</p>
<pre class=code>\
$ ps -o pid,rss,%cpu,cmd -p $(pgrep -u $USER '^Q$|^swaag$')
  PID    RSS  %CPU  CMD
 1000  58000  99.9  swaag
 1001  55000  99.9  swaag
 1002  59000  99.9  swaag
 1003    540   0.0  Q
 1004    540   0.0  Q
 1005    540   0.0  Q
 ...
 ...
 1097    540   0.0  Q
 1098    540   0.0  Q
 1099    540   0.0  Q
</pre>
  <h3>The <span class=mono>EXECUTION</span> Phase:</h3>
    <p>After a <span class=progName>SWAAG</span> process completes, the next <span class=progName>Q</span> in line will convert itself into a new <span class=progName>SWAAG</span> and start running.  The process listing would look something like this (notice that <span class=mono>PID 1000</span> is no longer in the list, and <span class=mono>PID 1003</span> has taken its place):</p>
<pre class=code>\
$ ps -o pid,rss,%cpu,cmd -p $(pgrep -u $USER '^Q$|^swaag$')
  PID    RSS  %CPU  CMD
 1001  55000  99.9  swaag
 1002  59000  99.9  swaag
 1003  57000  99.9  swaag
 1004    540   0.0  Q
 1005    540   0.0  Q
 1006    540   0.0  Q
 ...
 ...
 1097    540   0.0  Q
 1098    540   0.0  Q
 1099    540   0.0  Q
</pre>
    <p>This pattern continues until all <span class=progName>Q</span> processes have waited their turn and then converted themselves into <span class=progName>SWAAG</span> processes.</p>
  <h3>The <span class=mono>END</span> Phase:</h3>
    <p>This phase represents the point in time when all Q processes have been converted, and have finished running.</p>
</div>
<div class=exampleContainer>
  <div class=exampleSidebar>
    <p>This example introduces how to use <span class=progName>Q</span> as a single-instance process manager. It is often necessary to ensure that only one instance of an automatic periodic task is ever running at any given time, and Q makes this easy.</p>
    <p>One  <span class=progName>Q</span> option is introduced:</p>
    <ul>
      <li><span class=mono>MAX_Q</span> -- The number of processes which will wait for execution. Any process which would queue to a position over this limit exits immediately instead of queuing up. A value of <span class=mono>0</span> means that processes will never queue; they either execute immediately or exit immediately. A value of <span class=mono>-1</span> represents an unlimited queue size.</li>
    </ul>
  </div>
  <h2>Example #2: Running One Process at a Time</h2>
  <p>Pretend that you have a production PostgreSQL database that your business depends on. Data changes often, so you need to take hourly backups. Most of the time, those backups complete within the hour. However, if the database server is particularly busy, it could take longer. You can't really know in advance the maximum length of time that any one export could take, and you don't want more than one of these database export processes running at once. If it happens that a previous export process is still running when the next starts, the new one should just exit immediately without running. You never want these processes to overlap.
  <p class=codeIntro><span class=progName>Q</span> can also be used for this type of application. You would use an hourly cron job like this:</p>
<pre class=code>\
0 * * * * CONCURRENCY=1 MAX_Q=0 COMMAND=/usr/bin/pg_dump ~/bin/Q -U mypguser -f ~/pg_backups/mydb.sql mydb
</pre>
  <p>This will run <span class=progName>Q</span> each hour, instructing <span class=progName>Q</span> to run the command "<span class=mono>/usr/bin/pg_dump -U mypguser -f /home/myuser/pg_backups/mydb.sql mydb</span>" with <span class=mono>CONCURRENCY=1</span> and <span class=mono>MAX_Q=0</span>. This means that the <span class=progName>pg_dump</span> commands will execute one at a time (<span class=mono>CONCURRENCY=1</span>), and that processes never queue up, but instead exit immediately without running (<span class=mono>MAX_Q=0</span>).</p>
  <p>To understand how this works, it's helpful to visualize the process array. This visualization will assume <span class=mono>CONCURRENCY=3</span> and <span class=mono>MAX_Q=6</span> for increased demonstrative clarity:</p>
  <table class=illustrations>
    <tr class=illustrations>
      <td class="illustrations image">
        <div class=imgTitle>Structure Overview</div>
        <img src="${self.URL('/static/img/q_ex2_01_structure.png')}">
      </td>
      <td class="illustrations description">
        <p class=singlespace>The process array has two primary regions; the <span class=mono>RUNNING</span> region and the <span class=mono>WAITING</span> region.</p>
        <p>We are assuming <span class=mono>CONCURRENCY=3</span> and <span class=mono>MAX_Q=6</span>, so the process array has 3 <span class=mono>RUNNING</span> slots and 6 <span class=mono>WAITING</span> slots.</p>
        <p class=singlespace>Processes in the <span class=mono>WAITING</span> region are <span class=progName>Q</span> processes waiting their turn in line.</p>
        <p class=singlespace>Processes in the <span class=mono>RUNNING</span> region are no longer <span class=progName>Q</span> processes, but have already been converted into the target <span class=mono>COMMAND</span>.</p>
      </td>
    </tr>
    <tr class=illustrations>
      <td class="illustrations image">
        <div class=imgTitle>A Process is added to the Queue</div>
        <img src="${self.URL('/static/img/q_ex2_02_adding.png')}">
      </td>
      <td class="illustrations description">
        <p class=singlespace>In this image, we've initially populated the process array with some processes.</p>
        <p class=singlespace>The first 3 processes (labeled <span class=mono>1</span>, <span class=mono>2</span>, and <span class=mono>3</span>) immediately went into the <span class=mono>RUNNING</span> region, since the array was initially empty.</p>
        <p class=singlespace>The next 3 processes (labeled <span class=mono>4</span>, <span class=mono>5</span>, and <span class=mono>6</span>) went into the <span class=mono>WAITING</span> region, since the <span class=mono>RUNNING</span> region was already full.</p>
        <p>This image illustrates the addition of another process, labeled <span class=mono>7</span>. As expected, it inserts itself at the end of the process array.</p>
        <p>The result is that there are now 7 total processes in the process array, with three <span class=mono>RUNNING</span> and four <span class=mono>WAITING</span>.</p>
      </td>
    </tr>
    <tr class=illustrations>
      <td class="illustrations image">
        <div class=imgTitle>A RUNNING process finishes, and<br/>the next WAITING process takes its place</div>
        <img src="${self.URL('/static/img/q_ex2_03_removing.png')}">
      </td>
      <td class="illustrations description">
        <p class=singlespace>This image illustrates the completion of one of the <span class=mono>RUNNING</span> processes, in this case the process labeled <span class=mono>1</span>.</p>
        <p>The next-in-line process in the <span class=mono>WAITING</span> region moves to take its place, in this case the process labeled <span class=mono>4</span>. All processes move forward.</p>
        <p class=singlespace>The result is that <span class=progName>Q</span> process <span class=mono>4</span> has now been converted into its associated <span class=mono>COMMAND</span>.</p>
        <p>Processes <span class=mono>2</span> and <span class=mono>3</span> are still running (they haven't completed yet), and three process (<span class=mono>5</span>, <span class=mono>6</span>, and <span class=mono>7</span>) are left <span class=mono>WAITING</span>.</p>
      </td>
    </tr>
    <tr class=illustrations>
      <td class="illustrations image">
        <div class=imgTitle>A process is discarded when Queue is full</div>
        <img src="${self.URL('/static/img/q_ex2_04_full.png')}">
      </td>
      <td class="illustrations description">
        <p>This image illustrates that when the queue is completely full, any new <span class=progName>Q</span> processes exit immediately without ever running their <span class=mono>COMMAND</span>.</p>
        <p>The result is that no more processes than <span class=mono>MAX_Q</span> are ever queued up <span class=mono>WAITING</span>.</p>
      </td>
    </tr>
  </table>
  <p>The <span class=progName>Q</span> process array has two regions, the <span class=mono>RUNNING</span> region and the <span class=mono>WAITING</span> region. When a new <span class=progName>Q</span> process is launched, it inserts itself at the end of the array.</p>
  <ul>
    <li>If it lands in one of the first few spots, in the <span class=mono>RUNNING</span> region, then <span class=progName>Q</span> immediately executes the command.</li>
    <li>If it lands in the <span class=mono>WAITING</span> region, then <span class=progName>Q</span> will wait in line until it reaches the <span class=mono>RUNNING</span> region before executing its associated command.</li>
    <li>If it lands after the end of the queue, past the <span class=mono>WAITING</span> region, then all slots are already full. <span class=progName>Q</span> exits immediately without running the command at all.</li>
  </ul>
  <p>As soon as any one of the processes in the <span class=mono>RUNNING</span> region finishes, all of the <span class=progName>Q</span> processes waiting in line behind it move forward. This means that the next-in-line <span class=mono>WAITING</span> <span class=progName>Q</span> process will move into a <span class=mono>RUNNING</span> slot, and then <span class=progName>Q</span> will execute it. It also means that there is one more empty slot in the <span class=mono>WAITING</span> region, which a new <span class=progName>Q</span> process could come and fill.</p>
  <p>One important feature of this approach is that there is no "master" <span class=progName>Q</span> process which runs as a daemon and regulates all of the other processes. All of the <span class=progName>Q</span> processes are independent and you do not need to manage a "<span class=progName>Q</span> server" which handles the scheduling. Each individual <span class=progName>Q</span> process follows the following logic:</p>
  <ul> 
    <li>If <span class=mono>(position &lt;= CONCURRENCY)</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=mono>exec</span> associated command (which completes this <span class=progName>Q</span> process)</li>
    <br/>
    <li>If <span class=mono>(CONCURRENCY &lt; position &lt;= (CONCURRENCY + MAX_Q))</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=mono>sleep</span> awhile and then check <span class=mono>position</span> again.</li>
    <br/>
    <li>If <span class=mono>(position &gt; (CONCURRENCY + MAX_Q))</span>:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=mono>exit(-17)</span> without running the command.</li>
    <br/>
  </ul>
  <h3>Compile-time Options:</h3>
  <p>As demonstrated, <span class=progName>Q</span> uses environment variables for configuration. These settings can also be defined at compile-time. Furthermore, if you define a setting this way, it cannot be overridden with an environment variable. This is by design - it allows administrators to hard-code values and be sure that they don't change.</p>
  <p>To hard-code a value, define them as macros at compile time via the <span class=mono>CFLAGS</span> <span class=mono>make</span> variable. For example, the following will hard-code <span class=mono>CONCURRENCY=1</span> and <span class=mono>MAX_Q=0</span>, and rename the resulting file to <span class=mono>run_single</span>, because that's what it does:</p>
<pre class=code>
CPPFLAGS="-DCONCURRENCY=1 -DMAX_Q=0" make
mv ./Q ~/bin/run_single
</pre>
  <p>At this point, the "<span class=mono>run_single</span>" binary is <span class=progName>Q</span> with some hard-coded values. You would run the database cron using this new binary as follows:</p>
<pre class=code>\
0 * * * * COMMAND=/usr/bin/pg_dump ~/bin/run_single -U mypguser -f ~/pg_backups/mydb.sql mydb
</pre>
  <p>You now have a convenient portable binary application that runs a single instance of a program at once.</p>
  <p>Any of the following five variables can be defined at compile-time. Each of these answers a different question:</p>
  <ul>
    <li><span class=mono>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COMMAND</span>&nbsp;&nbsp;--&nbsp;&nbsp;Which program should run?</li>
    <li><span class=mono>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONCURRENCY</span>&nbsp;&nbsp;--&nbsp;&nbsp;How many instances can be running at once?</li>
    <li><span class=mono>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MAX_Q</span>&nbsp;&nbsp;--&nbsp;&nbsp;How many instances can wait in line if all running slots are full?</li>
    <li><span class=mono>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q_FILE</span>&nbsp;&nbsp;--&nbsp;&nbsp;How do we define which queue a process is put into?</li>
    <li><span class=mono>AUTO_CREATE_DIRS</span>&nbsp;&nbsp;--&nbsp;&nbsp;Should parent directories of the <span class=mono>Q_FILE</span> be created automatically?</li>
  </ul>
  <p>The variables <span class=mono>Q_FILE</span> and <span class=mono>AUTO_CREATE_DIRS</span> will be explained in more detail shortly.</p>
</div>
<div class=exampleContainer>
  <div class=exampleSidebar>
    <p>This example introduces how to use <span class=progName>Q</span> as a CGI request queue. This applies to any situation where you need to gracefully handle bursts of activity with a queue and handling them as soon as resources are available, in the order in which they were received.</p>
    <p>Two <span class=progName>Q</span> options are introduced:</p>
    <ul>
      <li><span class=mono>Q_FILE</span> -- Path to the file to queue processes into. This allows you to have different parallel queues for different types of processes. For example, maybe you want the incoming CGI requests for different domains to queue separately, so a single domain which receives a heavy traffic burst won't affect availability of other sites under your account.</li>
      <li><span class=mono>AUTO_CREATE_DIRS</span> -- By default, <span class=progName>Q</span> automatically creates the parent directories of <span class=mono>Q_FILE</span> if they don't exist. Set <span class=mono>AUTO_CREATE_DIRS</span> to <span class=mono>0</span> to suppress this behavior.</li>
    </ul>
  </div>
  <h2>Example #3: Running N processes at a time, allowing only M to be queued at once</h2>
  <p>Imagine that you are running a PHP 5.4 website in CGI mode. You want to handle 3 concurrent requests, but you also can't afford to queue unlimited numbers of requests because Apache processes are very heavy. You would like to limit the queue length to 20.</p>
  <p class=codeIntro>For this situation, it makes a lot of sense to create a compiled drop-in replacement for the PHP binary:</p>
<pre class=code>
CPPFLAGS="-DCONCURRENCY=3 -DMAX_Q=20 -DCOMMAND=/home/cgi-php/php54.cgi" make
mv ./Q ~/webapps/myapp/php54.cgi
</pre>
  <p>You can then place the binary in your webroot as shown above (<span class=mono>~/webapps/myapp/php54.cgi</span>), and you can add these directives to your <span class=mono>.htaccess</span> file:</p>
<pre class=code>
&lt;FilesMatch ^php54.cgi$&gt;
    SetHandler cgi-script
&lt;/FilesMatch&gt;
Action php-q /php54.cgi
&lt;FilesMatch \.(?i:php)$&gt;
    SetHandler php-q
&lt;/FilesMatch&gt;
</pre>
  <p>Then, when a PHP request comes in for this application, a <span class=progName>Q</span> process gets started <em>instead of</em> a normal <span class=mono>php54.cgi</span> process. The new <span class=progName>Q</span> process checks its <span class=mono>position</span> in the queue as described in the previous example. Once it's ready, it <span class=mono>exec</span>'s the <em>real</em> PHP binary.</p>
  <p>Under normal circumstances, the new <span class=progName>Q</span> process doesn't need to wait and just executes immediately. During a traffic spike, however, the <span class=progName>Q</span> processes queue up. It's much better to queue up several <span class=progName>Q</span> processes (540kB each) than many php54.cgi processes (48MB each). Furthermore, they will execute in FIFO order and will not overlap to the point of slowing each other down. As a result, this prevents traffic spikes from using large amounts of RAM and can even improve performance as well.</p>
  <p>In addition to the above, <span class=progName>Q</span> also provides powerful queuing flexibility. Instead of having a single queue for all of your <span class=mono>php54.cgi</span> processes (the default), you can specify different queues using the <span class=mono>Q_FILE</span> setting. To understand how this works, revisit the above example in more detail. When a PHP request comes in for a particular domain, a new <span class=progName>Q</span> process gets started instead of a normal <span class=mono>php54.cgi</span> process. The new <span class=progName>Q</span> process checks its <span class=mono>position</span> in its associated <span class=mono>Q_FILE</span>, and either executes immediately, waits in line, or else exits immediately depending on how many other <span class=progName>Q</span> processes are waiting in that same <span class=mono>Q_FILE</span>.</p>
  <p>By putting different domains into different queues, you can separate traffic. Imagine that you are a developer and hosting clients' websites, each of which should receive comparable performance. If one of those sites gets significantly more traffic than the others, that site will bog down the other sites. Applying <span class=progName>Q</span> could solve this problem nicely by placing each website into its own separate queue with, perhaps, <span class=mono>CONCURRENCY=2</span> and <span class=mono>MAX_Q=20</span>. The relatively busy site will experience longer load times during traffic spikes (requests having to wait for their turn to execute) but other clients' sites would remain fast as long as their own <span class=mono>RUNNING</span> regions remained unsaturated..</p>
  <p>Accomplishing such separate queues is straightforward because environment variables can be used in the <span class=mono>Q_FILE</span> path. To do this, simply compile in a <span class=mono>Q_FILE</span> which uses the domain ("<span class=mono>$SERVER_NAME</span>" -- a standard CGI environment variable) in its filename. This means multiple <span class=mono>Q_FILE</span>s (one for each domain) will exist, and requests for a particular domain will queue into its associated <span class=mono>Q_FILE</span>:</p>
<pre class=code>
CPPFLAGS="-DQ_FILE='~/.tmp/Q/cgi_$SERVER_NAME.Q' -DCONCURRENCY=3 -DMAX_Q=20 -DCOMMAND=/home/cgi-php/php54.cgi" make
mv ./Q ~/webapps/myapp/php54.cgi
</pre>
  <p>That's it. The <span class=mono>$SERVER_NAME</span> environment variable will be evaluated at runtime (it's set by <span class=mono>apache</span>), and requests will go into the appropriate <span class=mono>Q_FILE</span>. If the file doesn't exist, it will be created on first use. If the <span class=mono>AUTO_CREATE_DIRS</span> setting is not set to <span class=mono>0</span>, then any necessary parent directories for the <span class=mono>Q_FILE</span> will be created as needed. Finally, if for some reason the <span class=mono>Q_FILE</span> can't be created, <span class=progName>Q</span> will defer to always running the process immediately. This means you'll lose queuing functionality until the problem is fixed, but it won't break your websites.</p>
</div>


<h1>Manpage</h1>
<p>Here is <span class=progName>Q</span>'s standard help text, for your easy reference:</p>
<pre class=code>

Q Version 1.1.1  --  a FIFO worker queue, capable of running multiple workers at once.

Typical usage:  COMMAND=/usr/bin/rsync  ./Q  [args...]

The args get passed directly to COMMAND.

Environment Variables:

    COMMAND=path -- Required.  The path to the target executable.  Should usually be an absolute path.
    Q_FILE=path -- The path to the Q queue state file.  More info below.
    CONCURRENCY=num -- Controls the number of workers to run at once.  Default is 1.
    MAX_Q=num -- Controls the maximum queue size (# waiting to run).  Default is -1 (unlimited).
    AUTO_CREATE_DIRS -- Set to 0 to prevent the Q_FILE parent directories from being auto-created.
    VERBOSE -- Set to 1 to display verbose information.
    HELP -- Set to 1 to display this help message and then exit.

By default, Q_FILE is set to ~/.tmp/Q/cmd_$(basename $COMMAND).Q, but you can change this.
You can use the tilde (~) and environment variables ($VAR) in the Q_FILE.
This enables you to achieve some interesting queuing structures:

    Q_FILE=example.Q                     # A relative path can queue jobs based on $PWD.
    Q_FILE=/tmp/shared.Q                 # A system-wide queue.  (You would need to chmod 666 it.)
    Q_FILE='~/myjobs.Q'                  # Use a per-account queue.
    Q_FILE='~/.tmp/Q/cgi_$SERVER_NAME.Q' # Assuming this is for CGI processes, use a per-domain queue.

</pre>

<%def name="DL_TABLE(title, basePath)">
    <table class=downloads>
      <tr><th class=cornerLabel>${title}</td><th class=topLabel>PHP 5.2</th><th class=topLabel>PHP 5.3</th><th class=topLabel>PHP 5.4</th><th class=topLabel>CGI (Advanced)</th></tr>
      <tr><th class=leftLabel>Normal Account<br><span class=labelDesc>(If you have a 256MB/512MB plan)</span></td><td><a href="${basePath}/php52_normal.cgi">php52_normal.cgi</a></td><td><a href="${basePath}/php53_normal.cgi">php53_normal.cgi</a></td><td><a href="${basePath}/php54_normal.cgi">php54_normal.cgi</a></td><td rowspan=2><a href="${basePath}/Q">Q</a></td></tr>
      <tr><th class=leftLabel>Large Account<br><span class=labelDesc>(If you have a 1GB/2GB/4GB plan)</span></td><td><a href="${basePath}/php52_large.cgi">php52_large.cgi</a></td><td><a href="${basePath}/php53_large.cgi">php53_large.cgi</a></td><td><a href="${basePath}/php54_large.cgi">php54_large.cgi</a></td></tr>
    </table>
</%def>
<%def name='PAGE_CSS()'>
    <link rel="stylesheet" type="text/css" href="${self.URL('/static/css/home.css')}">
</%def>
